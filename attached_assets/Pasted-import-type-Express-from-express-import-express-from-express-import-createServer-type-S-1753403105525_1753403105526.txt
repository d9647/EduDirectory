import type { Express } from "express";
import express from "express";
import { createServer, type Server } from "http";
import path from "path";
import { storage } from "./storage";
import { setupAuth, isAuthenticated } from "./replitAuth";
import {
  insertTutoringProviderSchema,
  insertSummerCampSchema,
  insertInternshipSchema,
  insertJobSchema,
  insertEventSchema,
  insertReviewSchema,
  insertReportSchema,
} from "@shared/schema";
import { z } from "zod";
import multer from "multer";
import { importService } from "./import";
import fetch from "node-fetch";

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth middleware
  await setupAuth(app);

  // Auth routes
  app.get('/api/auth/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      res.json(user);
    } catch (error: any) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // Admin middleware
  const requireAdmin = async (req: any, res: any, next: any) => {
    try {
      if (!req.user) {
        return res.status(401).json({ message: "Authentication required" });
      }

      const userId = req.user.claims.sub;
      const userRole = await storage.getUserRole(userId);

      if (userRole !== "admin") {
        return res.status(403).json({ message: "Admin access required" });
      }

      next();
    } catch (error: any) {
      console.error("Error checking admin status:", error);
      res.status(500).json({ message: "Failed to verify admin status" });
    }
  };

  // User role management routes (admin only)
  app.put('/api/admin/users/:userId/role', isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { role } = req.body;

      if (!["admin", "user"].includes(role)) {
        return res.status(400).json({ message: "Invalid role. Must be 'admin' or 'user'" });
      }

      const updatedUser = await storage.updateUserRole(userId, role);
      res.json(updatedUser);
    } catch (error: any) {
      console.error("Error updating user role:", error);
      if (error.message === "User not found") {
        return res.status(404).json({ message: "User not found" });
      }
      res.status(500).json({ message: "Failed to update user role" });
    }
  });

  app.get('/api/admin/users', isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 10;
      const search = req.query.search as string || '';
      
      console.log(`Fetching users - page: ${page}, limit: ${limit}, search: "${search}"`);
      
      const result = await storage.getUsersWithPagination(page, limit, search);
      res.json(result);
    } catch (error: any) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  // User profile update route
  app.put('/api/auth/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;

      // Use the updateUserProfileSchema for validation
      const { updateUserProfileSchema } = await import("../shared/schema.js");
      const profileData = updateUserProfileSchema.parse(req.body);

      const updatedUser = await storage.updateUserProfile(userId, profileData);
      res.json(updatedUser);
    } catch (error: any) {
      console.error("Error updating user profile:", error);
      if (error.message === "User not found") {
        return res.status(404).json({ message: "User not found" });
      }
      if (error.name === "ZodError") {
        return res.status(400).json({ message: "Invalid profile data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to update profile" });
    }
  });

  // Tutoring Providers
  app.get('/api/tutoring-providers', async (req, res) => {
    try {
      const filters = {
        search: req.query.search as string,
        categories: req.query.categories ? (req.query.categories as string).split(',') : undefined,
        subjects: req.query.subjects ? (req.query.subjects as string).split(',') : undefined,
        type: req.query.type as string,
        city: req.query.city as string,
        state: req.query.state as string,
        sortBy: req.query.sortBy as string,
        sortOrder: (req.query.sortOrder as "asc" | "desc") || "desc",
        limit: req.query.limit ? parseInt(req.query.limit as string) : 5,
        offset: req.query.offset ? parseInt(req.query.offset as string) : 0,
      };

      const result = await storage.getTutoringProviders(filters);
      res.json(result);
    } catch (error: any) {
      console.error("Error fetching tutoring providers:", error);
      res.status(500).json({ message: "Failed to fetch tutoring providers" });
    }
  });

  app.get('/api/tutoring-providers/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const provider = await storage.getTutoringProvider(id);
      if (!provider) {
        return res.status(404).json({ message: "Provider not found" });
      }
      res.json(provider);
    } catch (error: any) {
      console.error("Error fetching tutoring provider:", error);
      res.status(500).json({ message: "Failed to fetch tutoring provider" });
    }
  });

  app.post('/api/tutoring-providers', async (req, res) => {
    try {
      const validatedData = insertTutoringProviderSchema.parse(req.body);
      const provider = await storage.createTutoringProvider(validatedData);
      res.status(201).json(provider);
    } catch (error: any) {
      console.error("Error creating tutoring provider:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create tutoring provider" });
    }
  });

  // Summer Camps
  app.get('/api/summer-camps', async (req, res) => {
    try {
      const filters = {
        search: req.query.search as string,
        categories: req.query.categories ? (req.query.categories as string).split(',') : undefined,
        tags: req.query.tags ? (req.query.tags as string).split(',') : undefined,
        selectivityLevel: req.query.selectivityLevel ? (req.query.selectivityLevel as string).split(',').map(Number) : undefined,
        cost: req.query.cost ? (req.query.cost as string).split(',') : undefined,
        city: req.query.city as string,
        state: req.query.state as string,
        hasScholarship: req.query.hasScholarship === 'true' ? true : req.query.hasScholarship === 'false' ? false : undefined,
        applicationAvailable: req.query.applicationAvailable === 'true' ? true : req.query.applicationAvailable === 'false' ? false : undefined,
        minimumAge: req.query.minimumAge ? parseInt(req.query.minimumAge as string) : undefined,
        sortBy: req.query.sortBy as string,
        sortOrder: (req.query.sortOrder as "asc" | "desc") || "desc",
        limit: req.query.limit ? parseInt(req.query.limit as string) : 5,
        offset: req.query.offset ? parseInt(req.query.offset as string) : 0,
      };

      const result = await storage.getSummerCamps(filters);
      res.json(result);
    } catch (error: any) {
      console.error("Error fetching summer camps:", error);
      res.status(500).json({ message: "Failed to fetch summer camps" });
    }
  });

  app.get('/api/summer-camps/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const camp = await storage.getSummerCamp(id);
      if (!camp) {
        return res.status(404).json({ message: "Camp not found" });
      }
      res.json(camp);
    } catch (error: any) {
      console.error("Error fetching summer camp:", error);
      res.status(500).json({ message: "Failed to fetch summer camp" });
    }
  });

  app.post('/api/summer-camps', async (req, res) => {
    try {
      const validatedData = insertSummerCampSchema.parse(req.body);
      const camp = await storage.createSummerCamp(validatedData);
      res.status(201).json(camp);
    } catch (error: any) {
      console.error("Error creating summer camp:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create summer camp" });
    }
  });

  // Internships
  app.get('/api/internships', async (req, res) => {
    try {
      const filters = {
        search: req.query.search as string,
        types: req.query.types ? (req.query.types as string).split(',') : undefined,
        selectivityLevel: req.query.selectivityLevel ? (req.query.selectivityLevel as string).split(',').map(Number) : undefined,
        compensation: req.query.compensation ? (req.query.compensation as string).split(',') : undefined,
        city: req.query.city as string,
        state: req.query.state as string,
        isRemote: req.query.isRemote === 'true' ? true : req.query.isRemote === 'false' ? false : undefined,
        hasMentorship: req.query.hasMentorship === 'true' ? true : req.query.hasMentorship === 'false' ? false : undefined,
        sortBy: req.query.sortBy as string,
        sortOrder: (req.query.sortOrder as "asc" | "desc") || "desc",
        limit: req.query.limit ? parseInt(req.query.limit as string) : 5,
        offset: req.query.offset ? parseInt(req.query.offset as string) : 0,
      };

      const result = await storage.getInternships(filters);
      res.json(result);
    } catch (error: any) {
      console.error("Error fetching internships:", error);
      res.status(500).json({ message: "Failed to fetch internships" });
    }
  });

  app.get('/api/internships/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const internship = await storage.getInternship(id);
      if (!internship) {
        return res.status(404).json({ message: "Internship not found" });
      }
      res.json(internship);
    } catch (error: any) {
      console.error("Error fetching internship:", error);
      res.status(500).json({ message: "Failed to fetch internship" });
    }
  });

  app.post('/api/internships', async (req, res) => {
    try {
      const validatedData = insertInternshipSchema.parse(req.body);
      const internship = await storage.createInternship(validatedData);
      res.status(201).json(internship);
    } catch (error: any) {
      console.error("Error creating internship:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create internship" });
    }
  });

  // Jobs
  app.get('/api/jobs', async (req, res) => {
    try {
      const filters = {
        search: req.query.search as string,
        categories: req.query.categories ? (req.query.categories as string).split(',') : undefined,
        compensation: req.query.compensation ? (req.query.compensation as string).split(',') : undefined,
        city: req.query.city as string,
        state: req.query.state as string,
        isRemote: req.query.isRemote === 'true' ? true : req.query.isRemote === 'false' ? false : undefined,
        minimumAge: req.query.minimumAge ? parseInt(req.query.minimumAge as string) : undefined,
        hasTraining: req.query.hasTraining === 'true' ? true : req.query.hasTraining === 'false' ? false : undefined,
        sortBy: req.query.sortBy as string,
        sortOrder: (req.query.sortOrder as "asc" | "desc") || "desc",
        limit: req.query.limit ? parseInt(req.query.limit as string) : 5,
        offset: req.query.offset ? parseInt(req.query.offset as string) : 0,
      };

      const result = await storage.getJobs(filters);
      res.json(result);
    } catch (error: any) {
      console.error("Error fetching jobs:", error);
      res.status(500).json({ message: "Failed to fetch jobs" });
    }
  });

  app.get('/api/jobs/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const job = await storage.getJob(id);
      if (!job) {
        return res.status(404).json({ message: "Job not found" });
      }
      res.json(job);
    } catch (error: any) {
      console.error("Error fetching job:", error);
      res.status(500).json({ message: "Failed to fetch job" });
    }
  });

  app.post('/api/jobs', async (req, res) => {
    try {
      const validatedData = insertJobSchema.parse(req.body);
      const job = await storage.createJob(validatedData);
      res.status(201).json(job);
    } catch (error: any) {
      console.error("Error creating job:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create job" });
    }
  });

  // Events
  app.get('/api/events', async (req, res) => {
    try {
      const filters = {
        search: req.query.search as string,
        categories: req.query.categories ? (req.query.categories as string).split(',') : undefined,
        targetAudience: req.query.targetAudience ? (req.query.targetAudience as string).split(',') : undefined,
        eventDate: req.query.eventDate as string,
        dateRange: req.query.startDate && req.query.endDate ? {
          start: req.query.startDate as string,
          end: req.query.endDate as string
        } : undefined,
        city: req.query.city as string,
        state: req.query.state as string,
        zipcode: req.query.zipcode as string,
        distance: req.query.distance ? parseInt(req.query.distance as string) : undefined,
        cost: req.query.cost ? (req.query.cost as string).split(',') : undefined,
        registrationRequired: req.query.registrationRequired === 'true' ? true : req.query.registrationRequired === 'false' ? false : undefined,
        sortBy: req.query.sortBy as string,
        sortOrder: (req.query.sortOrder as "asc" | "desc") || "asc",
        limit: req.query.limit ? parseInt(req.query.limit as string) : 5,
        offset: req.query.offset ? parseInt(req.query.offset as string) : 0,
      };

      const result = await storage.getEvents(filters);
      res.json(result);
    } catch (error: any) {
      console.error("Error fetching events:", error);
      res.status(500).json({ message: "Failed to fetch events" });
    }
  });

  app.get('/api/events/:id', async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const event = await storage.getEvent(id);
      if (!event) {
        return res.status(404).json({ message: "Event not found" });
      }
      res.json(event);
    } catch (error: any) {
      console.error("Error fetching event:", error);
      res.status(500).json({ message: "Failed to fetch event" });
    }
  });

  app.post('/api/events', async (req, res) => {
    try {
      let validatedData = insertEventSchema.parse(req.body);
      // Geocode if address is present and lat/lng are missing
      if (validatedData.address && (validatedData.latitude == null || validatedData.longitude == null)) {
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(validatedData.address)}`;
        const geoRes = await fetch(url);
        const geoData = await geoRes.json();
        if (geoData && geoData.length > 0) {
          validatedData.latitude = parseFloat(geoData[0].lat);
          validatedData.longitude = parseFloat(geoData[0].lon);
        }
      }
      const event = await storage.createEvent(validatedData);
      res.status(201).json(event);
    } catch (error: any) {
      console.error("Error creating event:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create event" });
    }
  });

  // Reviews
  app.get('/api/reviews/:listingType/:listingId', async (req, res) => {
    try {
      const { listingType, listingId } = req.params;
      const reviews = await storage.getReviews(listingType, parseInt(listingId));
      res.json(reviews);
    } catch (error: any) {
      console.error("Error fetching reviews:", error);
      res.status(500).json({ message: "Failed to fetch reviews" });
    }
  });

  app.get('/api/reviews/:listingType/:listingId/user-reviewed', isAuthenticated, async (req: any, res) => {
    try {
      const { listingType, listingId } = req.params;
      const userId = req.user.claims.sub;
      const hasReviewed = await storage.hasUserReviewed(userId, listingType, parseInt(listingId));
      res.json({ hasReviewed });
    } catch (error: any) {
      console.error("Error checking user review status:", error);
      res.status(500).json({ message: "Failed to check review status" });
    }
  });

  app.post('/api/reviews', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validatedData = insertReviewSchema.parse({ ...req.body, userId });
      const review = await storage.createReview(validatedData);
      res.status(201).json(review);
    } catch (error: any) {
      console.error("Error creating review:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      if (error.message === 'User has already reviewed this listing') {
        return res.status(409).json({ message: "You have already reviewed this listing. You can only submit one review per listing." });
      }
      res.status(500).json({ message: "Failed to create review" });
    }
  });

  app.put('/api/reviews/:id', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const id = parseInt(req.params.id);

      // Check if the review belongs to the user or if user is admin
      const existingReview = await storage.getReviewById(id);
      if (!existingReview) {
        return res.status(404).json({ message: "Review not found" });
      }

      const userRole = await storage.getUserRole(userId);
      if (existingReview.userId !== userId && userRole !== 'admin') {
        return res.status(403).json({ message: "Not authorized to edit this review" });
      }

      const validatedData = insertReviewSchema.partial().parse(req.body);
      const review = await storage.updateReview(id, validatedData);
      res.json(review);
    } catch (error: any) {
      console.error("Error updating review:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to update review" });
    }
  });

  app.delete('/api/reviews/:id', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const id = parseInt(req.params.id);

      // Check if the review belongs to the user or if user is admin
      const existingReview = await storage.getReviewById(id);
      if (!existingReview) {
        return res.status(404).json({ message: "Review not found" });
      }

      const userRole = await storage.getUserRole(userId);
      if (existingReview.userId !== userId && userRole !== 'admin') {
        return res.status(403).json({ message: "Not authorized to delete this review" });
      }

      await storage.deleteReview(id, userId);
      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting review:", error);
      res.status(500).json({ message: "Failed to delete review" });
    }
  });

  // Thumbs Up
  app.post('/api/thumbs-up', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { listingType, listingId } = req.body;
      const isThumbedUp = await storage.toggleThumbsUp(userId, listingType, parseInt(listingId));
      res.json({ isThumbedUp });
    } catch (error: any) {
      console.error("Error toggling thumbs up:", error);
      res.status(500).json({ message: "Failed to toggle thumbs up" });
    }
  });

  app.get('/api/thumbs-up/:listingType/:listingId', async (req, res) => {
    try {
      const { listingType, listingId } = req.params;
      const count = await storage.getThumbsUpCount(listingType, parseInt(listingId));
      res.json({ count });
    } catch (error: any) {
      console.error("Error fetching thumbs up count:", error);
      res.status(500).json({ message: "Failed to fetch thumbs up count" });
    }
  });

  app.get('/api/thumbs-up/:listingType/:listingId/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { listingType, listingId } = req.params;
      const hasThumbedUp = await storage.hasUserThumbedUp(userId, listingType, parseInt(listingId));
      res.json({ hasThumbedUp });
    } catch (error: any) {
      console.error("Error checking thumbs up status:", error);
      res.status(500).json({ message: "Failed to check thumbs up status" });
    }
  });

  // View Tracking
  app.post('/api/views/track', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { listingType, listingId } = req.body as { listingType: string; listingId: string };
      const clientIp = req.ip;

      // Map listingType to table name
      const typeToTable: Record<string, string> = {
        'tutoring': 'tutoring_providers',
        'camp': 'summer_camps',
        'internship': 'internships',
        'job': 'jobs',
        'event': 'events'
      };
      const tableName = typeToTable[listingType as string];
      if (!tableName) return res.status(400).json({ error: 'Invalid listing type' });

      // Correct argument order!
      const wasTracked = await storage.trackView(tableName, parseInt(listingId), userId, clientIp);
      res.json({ wasTracked });
    } catch (error: any) {
      console.error("Error tracking view:", error);
      res.status(500).json({ message: "Failed to track view" });
    }
  });

  // Bookmarks
  app.post('/api/bookmarks', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { listingType, listingId } = req.body;
      const isBookmarked = await storage.toggleBookmark(userId, listingType, parseInt(listingId));
      res.json({ isBookmarked });
    } catch (error: any) {
      console.error("Error toggling bookmark:", error);
      res.status(500).json({ message: "Failed to toggle bookmark" });
    }
  });

  app.get('/api/bookmarks', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 5;
      const offset = req.query.offset ? parseInt(req.query.offset as string) : 0;

      const result = await storage.getUserBookmarks(userId, { limit, offset });
      res.json(result);
    } catch (error: any) {
      console.error("Error fetching bookmarks:", error);
      res.status(500).json({ message: "Failed to fetch bookmarks" });
    }
  });

  app.get('/api/bookmarks/:listingType/:listingId/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { listingType, listingId } = req.params;
      const isBookmarked = await storage.hasUserBookmarked(userId, listingType, parseInt(listingId));
      res.json({ isBookmarked });
    } catch (error: any) {
      console.error("Error checking bookmark status:", error);
      res.status(500).json({ message: "Failed to check bookmark status" });
    }
  });

  // Reports
  app.post('/api/reports', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validatedData = insertReportSchema.parse({ ...req.body, userId });
      const report = await storage.createReport(validatedData);
      res.status(201).json(report);
    } catch (error: any) {
      console.error("Error creating report:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create report" });
    }
  });

  // Admin routes
  app.get('/api/admin/pending-approvals', isAuthenticated, async (req: any, res) => {
    try {
      // TODO: Add admin role check
      const pendingApprovals = await storage.getPendingApprovals();
      res.json(pendingApprovals);
    } catch (error: any) {
      console.error("Error fetching pending approvals:", error);
      res.status(500).json({ message: "Failed to fetch pending approvals" });
    }
  });

  app.get('/api/admin/live-listings', isAuthenticated, async (req: any, res) => {
    try {
      // TODO: Add admin role check
      const liveListings = await storage.getLiveListings();
      res.json(liveListings);
    } catch (error: any) {
      console.error("Error fetching live listings:", error);
      res.status(500).json({ message: "Failed to fetch live listings" });
    }
  });

  app.get('/api/admin/search-listings/:type', isAuthenticated, async (req: any, res) => {
    try {
      // TODO: Add admin role check
      const { type } = req.params;
      const { query } = req.query;

      if (!query) {
        return res.json([]);
      }

      const results = await storage.searchListings(type, query);
      res.json(results);
    } catch (error: any) {
      console.error("Error searching listings:", error);
      res.status(500).json({ message: "Failed to search listings" });
    }
  });

  app.post('/api/admin/deactivate/:type/:id', isAuthenticated, async (req: any, res) => {
    try {
      // TODO: Add admin role check
      const { type, id } = req.params;
      await storage.deactivateListing(type, parseInt(id));
      res.json({ message: "Listing deactivated successfully" });
    } catch (error: any) {
      console.error("Error deactivating listing:", error);
      res.status(500).json({ message: "Failed to deactivate listing" });
    }
  });

  app.post('/api/admin/activate/:type/:id', isAuthenticated, async (req: any, res) => {
    try {
      // TODO: Add admin role check
      const { type, id } = req.params;
      await storage.activateListing(type, parseInt(id));
      res.json({ message: "Listing activated successfully" });
    } catch (error: any) {
      console.error("Error activating listing:", error);
      res.status(500).json({ message: "Failed to activate listing" });
    }
  });

  app.post('/api/admin/approve/:type/:id', isAuthenticated, async (req: any, res) => {
    try {
      // TODO: Add admin role check
      const { type, id } = req.params;
      const listingId = parseInt(id);

      switch (type) {
        case 'tutoring-provider':
          await storage.approveTutoringProvider(listingId);
          break;
        case 'summer-camp':
          await storage.approveSummerCamp(listingId);
          break;
        case 'internship':
          await storage.approveInternship(listingId);
          break;
        case 'job':
          await storage.approveJob(listingId);
          break;
        case 'event':
          await storage.approveEvent(listingId);
          break;
        default:
          return res.status(400).json({ message: "Invalid listing type" });
      }

      res.json({ message: "Approved successfully" });
    } catch (error: any) {
      console.error("Error approving listing:", error);
      res.status(500).json({ message: "Failed to approve listing" });
    }
  });

  app.get('/api/admin/reports', isAuthenticated, async (req: any, res) => {
    try {
      // TODO: Add admin role check
      const reports = await storage.getReports();
      res.json(reports);
    } catch (error: any) {
      console.error("Error fetching reports:", error);
      res.status(500).json({ message: "Failed to fetch reports" });
    }
  });

  app.post('/api/admin/reports/:id/resolve', isAuthenticated, async (req: any, res) => {
    try {
      // TODO: Add admin role check
      const id = parseInt(req.params.id);
      await storage.resolveReport(id);
      res.json({ message: "Report resolved successfully" });
    } catch (error: any) {
      console.error("Error resolving report:", error);
      res.status(500).json({ message: "Failed to resolve report" });
    }
  });

  // Admin edit routes
  app.put('/api/admin/edit/:type/:id', isAuthenticated, async (req: any, res) => {
    try {
      // TODO: Add admin role check
      const { type, id } = req.params;
      const listingId = parseInt(id);
      const updateData = { ...req.body };

      console.log('Original updateData:', JSON.stringify(updateData, null, 2));

      // Remove fields that shouldn't be updated through admin edit
      const protectedFields = ['id', 'submittedAt', 'approvedAt', 'createdAt', 'updatedAt'];
      protectedFields.forEach(field => {
        delete updateData[field];
      });

      // Clean up undefined and empty string values
      Object.keys(updateData).forEach(key => {
        if (updateData[key] === undefined || updateData[key] === '') {
          delete updateData[key];
        }
      });

      // Convert date strings to Date objects for database compatibility (these are date fields, not timestamp)
      const dateFields = ['applicationOpen', 'applicationDeadline', 'openingDate', 'closingDate'];

      for (const field of dateFields) {
        if (updateData[field] !== undefined) {
          if (typeof updateData[field] === 'string' && updateData[field].trim()) {
            const dateValue = new Date(updateData[field]);
            if (!isNaN(dateValue.getTime())) {
              updateData[field] = dateValue;
              console.log(`Converted ${field} to Date:`, dateValue);
            } else {
              console.log(`Invalid date value for field ${field}: ${updateData[field]}`);
              delete updateData[field];
            }
          } else {
            delete updateData[field];
          }
        }
      }

      // Convert string arrays back to arrays if they were serialized
      const arrayFields = ['categories', 'subjects', 'types', 'tags', 'duration', 'jobType', 'schedule'];

      for (const field of arrayFields) {
        if (updateData[field] && typeof updateData[field] === 'string') {
          updateData[field] = updateData[field].split(',').map(item => item.trim()).filter(Boolean);
        }
      }

      // Convert numeric fields
      if (updateData.selectivityLevel !== undefined) {
        updateData.selectivityLevel = parseInt(updateData.selectivityLevel) || null;
      }
      if (updateData.minimumAge !== undefined) {
        updateData.minimumAge = parseInt(updateData.minimumAge) || null;
      }

      // Convert decimal fields for salary ranges
      if (updateData.salaryMin !== undefined) {
        updateData.salaryMin = parseFloat(updateData.salaryMin) || null;
      }
      if (updateData.salaryMax !== undefined) {
        updateData.salaryMax = parseFloat(updateData.salaryMax) || null;
      }

      // Convert decimal fields for coordinates (events)
      if (updateData.latitude !== undefined) {
        updateData.latitude = updateData.latitude ? parseFloat(updateData.latitude) : null;
      }
      if (updateData.longitude !== undefined) {
        updateData.longitude = updateData.longitude ? parseFloat(updateData.longitude) : null;
      }

      // Convert boolean fields
      const booleanFields = ['isRemote', 'hasScholarship', 'applicationAvailable', 'hasMentorship', 'hasTraining', 'hasAdvancement', 'requiresTransportation', 'requiresResume', 'isOngoing'];
      booleanFields.forEach(field => {
        if (updateData[field] !== undefined) {
          updateData[field] = updateData[field] === 'true' || updateData[field] === true;
        }
      });

      console.log('Processed updateData:', JSON.stringify(updateData, null, 2));

      let updatedListing;
      switch (type) {
        case 'tutoring-provider':
          updatedListing = await storage.updateTutoringProvider(listingId, updateData);
          break;
        case 'summer-camp':
          updatedListing = await storage.updateSummerCamp(listingId, updateData);
          break;
        case 'internship':
          updatedListing = await storage.updateInternship(listingId, updateData);
          break;
        case 'job':
          updatedListing = await storage.updateJob(listingId, updateData);
          break;
        case 'event':
          updatedListing = await storage.updateEvent(listingId, updateData);
          break;
        default:
          return res.status(400).json({ message: "Invalid listing type" });
      }

      res.json(updatedListing);
    } catch (error: any) {
      console.error("Error updating listing:", error);
      res.status(500).json({ message: "Failed to update listing" });
    }
  });

  // Google Sheets Template
  app.get('/api/template', (req, res) => {
    res.sendFile(path.join(process.cwd(), 'google-sheets-template.html'));
  });

  // Google Sheets Import Guide
  app.get('/api/import-guide', (req, res) => {
    res.sendFile(path.join(process.cwd(), 'google-sheets-import-guide.html'));
  });

  // Setup multer for file uploads
  const upload = multer({
    dest: 'uploads/',
    limits: {
      fileSize: 5 * 1024 * 1024, // 5MB limit
    },
    fileFilter: (req, file, cb) => {
      if (file.mimetype.startsWith('image/')) {
        cb(null, true);
      } else {
        cb(new Error('Only image files are allowed'));
      }
    }
  });

  // Photo upload endpoint
  app.post('/api/upload', upload.single('photo'), (req, res) => {
    try {
      console.log('Upload request received');
      console.log('Request headers:', req.headers);
      console.log('Request file:', req.file);
      console.log('Request body:', req.body);
      
      if (!req.file) {
        console.log('No file found in request');
        return res.status(400).json({ message: 'No file uploaded' });
      }

      console.log('File details:', {
        fieldname: req.file.fieldname,
        originalname: req.file.originalname,
        encoding: req.file.encoding,
        mimetype: req.file.mimetype,
        size: req.file.size,
        filename: req.file.filename
      });

      // For now, return a static URL. In a real app, you'd upload to a cloud service
      const photoUrl = `/uploads/${req.file.filename}`;

      res.json({ url: photoUrl });
    } catch (error: any) {
      console.error('Error uploading photo:', error);
      res.status(500).json({ message: 'Failed to upload photo' });
    }
  });

  // Serve uploaded files
  app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));

  // CSV import setup
  const csvUpload = multer({ 
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 } // 10MB limit
  });

  // Import routes (Admin only)
  app.post('/api/admin/import/tutoring-providers', isAuthenticated, csvUpload.single('csvFile'), async (req, res) => {
    try {
      console.log('Import request received for tutoring providers');
      
      if (!req.file) {
        console.log('No file uploaded in request');
        return res.status(400).json({ message: "No file uploaded" });
      }

      console.log('File received:', {
        fieldname: req.file.fieldname,
        originalname: req.file.originalname,
        encoding: req.file.encoding,
        mimetype: req.file.mimetype,
        size: req.file.size
      });

      const csvData = req.file.buffer.toString('utf-8');
      console.log('CSV data converted from buffer, length:', csvData.length);
      
      const result = await importService.importTutoringProviders(csvData);
      console.log('Import result:', result);

      res.json({
        message: `Import completed: ${result.success} successful, ${result.errors.length} errors`,
        success: result.success,
        errors: result.errors
      });
    } catch (error: any) {
      console.error("Error importing tutoring providers:", error);
      console.error("Error stack:", error.stack);
      res.status(500).json({ message: "Failed to import tutoring providers", error: error.message });
    }
  });

  app.post('/api/admin/import/summer-camps', isAuthenticated, csvUpload.single('csvFile'), async (req, res) => {
    try {
      console.log('Import request received for summer camps');
      
      if (!req.file) {
        console.log('No file uploaded in request');
        return res.status(400).json({ message: "No file uploaded" });
      }

      console.log('File received:', {
        fieldname: req.file.fieldname,
        originalname: req.file.originalname,
        encoding: req.file.encoding,
        mimetype: req.file.mimetype,
        size: req.file.size
      });

      const csvData = req.file.buffer.toString('utf-8');
      console.log('CSV data converted from buffer, length:', csvData.length);
      
      const result = await importService.importSummerCamps(csvData);
      console.log('Import result:', result);

      res.json({
        message: `Import completed: ${result.success} successful, ${result.errors.length} errors`,
        success: result.success,
        errors: result.errors
      });
    } catch (error: any) {
      console.error("Error importing summer camps:", error);
      console.error("Error stack:", error.stack);
      res.status(500).json({ message: "Failed to import summer camps", error: error.message });
    }
  });

  app.post('/api/admin/import/internships', isAuthenticated, csvUpload.single('csvFile'), async (req, res) => {
    try {
      console.log('Import request received for internships');
      
      if (!req.file) {
        console.log('No file uploaded in request');
        return res.status(400).json({ message: "No file uploaded" });
      }

      console.log('File received:', {
        fieldname: req.file.fieldname,
        originalname: req.file.originalname,
        encoding: req.file.encoding,
        mimetype: req.file.mimetype,
        size: req.file.size
      });

      const csvData = req.file.buffer.toString('utf-8');
      console.log('CSV data converted from buffer, length:', csvData.length);
      
      const result = await importService.importInternships(csvData);
      console.log('Import result:', result);

      res.json({
        message: `Import completed: ${result.success} successful, ${result.errors.length} errors`,
        success: result.success,
        errors: result.errors
      });
    } catch (error: any) {
      console.error("Error importing internships:", error);
      console.error("Error stack:", error.stack);
      res.status(500).json({ message: "Failed to import internships", error: error.message });
    }
  });

  app.post('/api/admin/import/jobs', isAuthenticated, csvUpload.single('csvFile'), async (req, res) => {
    try {
      console.log('Import request received for jobs');
      
      if (!req.file) {
        console.log('No file uploaded in request');
        return res.status(400).json({ message: "No file uploaded" });
      }

      console.log('File received:', {
        fieldname: req.file.fieldname,
        originalname: req.file.originalname,
        encoding: req.file.encoding,
        mimetype: req.file.mimetype,
        size: req.file.size
      });

      const csvData = req.file.buffer.toString('utf-8');
      console.log('CSV data converted from buffer, length:', csvData.length);
      
      const result = await importService.importJobs(csvData);
      console.log('Import result:', result);

      res.json({
        message: `Import completed: ${result.success} successful, ${result.errors.length} errors`,
        success: result.success,
        errors: result.errors
      });
    } catch (error: any) {
      console.error("Error importing jobs:", error);
      console.error("Error stack:", error.stack);
      res.status(500).json({ message: "Failed to import jobs", error: error.message });
    }
  });

  // Delete routes (Admin only)
  app.delete('/api/admin/delete/tutoring-provider/:id', isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`Deleting tutoring provider with ID: ${id}`);
      await storage.deleteTutoringProvider(id);
      console.log(`Successfully deleted tutoring provider ${id}`);
      res.json({ message: "Tutoring provider deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting tutoring provider:", error);
      res.status(500).json({ message: "Failed to delete tutoring provider" });
    }
  });

  app.delete('/api/admin/delete/summer-camp/:id', isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`Deleting summer camp with ID: ${id}`);
      await storage.deleteSummerCamp(id);
      console.log(`Successfully deleted summer camp ${id}`);
      res.json({ message: "Summer camp deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting summer camp:", error);
      res.status(500).json({ message: "Failed to delete summer camp" });
    }
  });

  app.delete('/api/admin/delete/internship/:id', isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`Deleting internship with ID: ${id}`);
      await storage.deleteInternship(id);
      console.log(`Successfully deleted internship ${id}`);
      res.json({ message: "Internship deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting internship:", error);
      res.status(500).json({ message: "Failed to delete internship" });
    }
  });

  app.delete('/api/admin/delete/job/:id', isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`Deleting job with ID: ${id}`);
      await storage.deleteJob(id);
      console.log(`Successfully deleted job ${id}`);
      res.json({ message: "Job deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting job:", error);
      res.status(500).json({ message: "Failed to delete job" });
    }
  });

  app.delete('/api/admin/delete/event/:id', isAuthenticated, requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`Deleting event with ID: ${id}`);
      await storage.deleteEvent(id);
      console.log(`Successfully deleted event ${id}`);
      res.json({ message: "Event deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting event:", error);
      res.status(500).json({ message: "Failed to delete event" });
    }
  });

  // View tracking endpoint
  app.post('/api/views/track', isAuthenticated, async (req, res) => {
    try {
      const { listingType, listingId } = req.body;
      const userId = req.user.claims.sub;
      
      console.log(`[DEBUG] API received: listingType=${listingType}, listingId=${listingId}, userId=${userId}`);
      
      // Convert listingType to table names and get IP address
      const tableMapping = {
        'tutoring': 'tutoring_providers',
        'camp': 'summer_camps', 
        'internship': 'internships',
        'job': 'jobs',
        'event': 'events'
      };
      
      const tableName = tableMapping[listingType];
      if (!tableName) {
        console.log(`[DEBUG] Invalid listing type: ${listingType}`);
        return res.status(400).json({ message: "Invalid listing type" });
      }
      
      // Get client IP address for rate limiting
      const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
      
      console.log(`[DEBUG] Calling trackView with: tableName=${tableName}, listingId=${listingId}, userId=${userId}, clientIp=${clientIp}`);
      const result = await storage.trackView(tableName, listingId, userId, clientIp);
      console.log(`[DEBUG] trackView result:`, result);
      res.json(result);
    } catch (error) {
      console.error("Error tracking view:", error);
      res.status(500).json({ message: "Failed to track view" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
